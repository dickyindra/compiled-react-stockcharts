{"version":3,"sources":["../../../src/lib/scale/financeDiscontinuousScale.js"],"names":["financeDiscontinuousScale","MAX_LEVEL","length","index","futureProvider","backingLinearScale","Error","scale","x","invert","inverted","Math","round","domain","arguments","range","rangeRound","clamp","interpolate","ticks","m","flexTicks","backingTicks","ticksMap","domainStart","domainEnd","start","max","ceil","abs","end","min","floor","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","set","unsortedTicks","concat","map","d","sort","ticksSet","distance","remove","tickValues","values","parseInt","tickFormat","format","date","getTime","value","nice","copy"],"mappings":"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","file":"financeDiscontinuousScale.js","sourcesContent":["import { set, map } from \"d3-collection\";\nimport { ascending } from \"d3-array\";\nimport { scaleLinear } from \"d3-scale\";\n\nimport { isDefined, isNotDefined, head, last } from \"../utils\";\nimport { levelDefinition } from \"./levels\";\n\nconst MAX_LEVEL = levelDefinition.length - 1;\n\nexport default function financeDiscontinuousScale(\n    index,\n    futureProvider,\n    backingLinearScale = scaleLinear()\n) {\n    if (isNotDefined(index))\n        throw new Error(\n            \"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\"\n        );\n\n    function scale(x) {\n        return backingLinearScale(x);\n    }\n    scale.invert = function (x) {\n        const inverted = backingLinearScale.invert(x);\n        return Math.round(inverted * 10000) / 10000;\n    };\n    scale.domain = function (x) {\n        if (!arguments.length) return backingLinearScale.domain();\n        backingLinearScale.domain(x);\n        return scale;\n    };\n    scale.range = function (x) {\n        if (!arguments.length) return backingLinearScale.range();\n        backingLinearScale.range(x);\n        return scale;\n    };\n    scale.rangeRound = function (x) {\n        return backingLinearScale.range(x);\n    };\n    scale.clamp = function (x) {\n        if (!arguments.length) return backingLinearScale.clamp();\n        backingLinearScale.clamp(x);\n        return scale;\n    };\n    scale.interpolate = function (x) {\n        if (!arguments.length) return backingLinearScale.interpolate();\n        backingLinearScale.interpolate(x);\n        return scale;\n    };\n    scale.ticks = function (m, flexTicks) {\n        const backingTicks = backingLinearScale.ticks(m);\n        const ticksMap = map();\n\n        const [domainStart, domainEnd] = backingLinearScale.domain();\n\n        const start =\n            Math.max(Math.ceil(domainStart), head(index).index) +\n            Math.abs(head(index).index);\n        const end =\n            Math.min(Math.floor(domainEnd), last(index).index) +\n            Math.abs(head(index).index);\n\n        if (Math.floor(domainEnd) > end) {\n            // console.log(end, domainEnd, index);\n        }\n\n        const desiredTickCount = Math.ceil(\n            ((end - start) / (domainEnd - domainStart)) * backingTicks.length\n        );\n\n        for (let i = MAX_LEVEL; i >= 0; i--) {\n            const ticksAtLevel = ticksMap.get(i);\n            const temp = isNotDefined(ticksAtLevel) ? [] : ticksAtLevel.slice();\n\n            for (let j = start; j <= end; j++) {\n                if (index[j].level === i) {\n                    temp.push(index[j]);\n                }\n            }\n\n            ticksMap.set(i, temp);\n        }\n\n        let unsortedTicks = [];\n        for (let i = MAX_LEVEL; i >= 0; i--) {\n            if (\n                ticksMap.get(i).length + unsortedTicks.length >\n                desiredTickCount * 1.5\n            )\n                break;\n            unsortedTicks = unsortedTicks.concat(\n                ticksMap.get(i).map((d) => d.index)\n            );\n        }\n\n        const ticks = unsortedTicks.sort(ascending);\n\n        // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n        if (!flexTicks && end - start > ticks.length) {\n            const ticksSet = set(ticks);\n\n            const d = Math.abs(head(index).index);\n\n            // ignore ticks within this distance\n            const distance = Math.ceil(\n                (backingTicks.length > 0\n                    ? (last(backingTicks) - head(backingTicks)) /\n                      backingTicks.length /\n                      4\n                    : 1) * 1.5\n            );\n\n            for (let i = 0; i < ticks.length - 1; i++) {\n                for (let j = i + 1; j < ticks.length; j++) {\n                    if (ticks[j] - ticks[i] <= distance) {\n                        ticksSet.remove(\n                            index[ticks[i] + d].level >=\n                                index[ticks[j] + d].level\n                                ? ticks[j]\n                                : ticks[i]\n                        );\n                    }\n                }\n            }\n\n            const tickValues = ticksSet.values().map((d) => parseInt(d, 10));\n\n            // console.log(ticks.length, tickValues, level);\n            // console.log(ticks, tickValues, distance);\n\n            return tickValues;\n        }\n\n        return ticks;\n    };\n    scale.tickFormat = function () {\n        return function (x) {\n            const d = Math.abs(head(index).index);\n            const { format, date } = index[Math.floor(x + d)];\n\n            if (date.getTime() == 0) {\n                return \"\";\n            }\n\n            return format(date);\n        };\n    };\n    scale.value = function (x) {\n        const d = Math.abs(head(index).index);\n        if (isDefined(index[Math.floor(x + d)])) {\n            const { date } = index[Math.floor(x + d)];\n            return date;\n        }\n    };\n    scale.nice = function (m) {\n        backingLinearScale.nice(m);\n        return scale;\n    };\n    scale.index = function (x) {\n        if (!arguments.length) return index;\n        index = x;\n        return scale;\n    };\n    scale.copy = function () {\n        return financeDiscontinuousScale(\n            index,\n            futureProvider,\n            backingLinearScale.copy()\n        );\n    };\n    return scale;\n}\n"]}