{"version":3,"sources":["../../../../src/lib/scale/financeDiscontinuousScale.js"],"names":["set","map","ascending","scaleLinear","isDefined","isNotDefined","head","last","levelDefinition","MAX_LEVEL","length","financeDiscontinuousScale","index","futureProvider","backingLinearScale","Error","scale","x","invert","inverted","Math","round","domain","arguments","range","rangeRound","clamp","interpolate","ticks","m","flexTicks","backingTicks","ticksMap","domainStart","domainEnd","start","max","ceil","abs","end","min","floor","desiredTickCount","i","ticksAtLevel","get","temp","slice","j","level","push","unsortedTicks","concat","d","sort","ticksSet","distance","remove","tickValues","values","parseInt","tickFormat","format","date","getTime","value","nice","copy"],"mappings":"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","file":"financeDiscontinuousScale.js","sourcesContent":["import { set, map } from \"d3-collection\";\r\nimport { ascending } from \"d3-array\";\r\nimport { scaleLinear } from \"d3-scale\";\r\n\r\nimport { isDefined, isNotDefined, head, last } from \"../utils\";\r\nimport { levelDefinition } from \"./levels\";\r\n\r\nconst MAX_LEVEL = levelDefinition.length - 1;\r\n\r\nexport default function financeDiscontinuousScale(\r\n    index,\r\n    futureProvider,\r\n    backingLinearScale = scaleLinear()\r\n) {\r\n    if (isNotDefined(index))\r\n        throw new Error(\r\n            \"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\"\r\n        );\r\n\r\n    function scale(x) {\r\n        return backingLinearScale(x);\r\n    }\r\n    scale.invert = function (x) {\r\n        const inverted = backingLinearScale.invert(x);\r\n        return Math.round(inverted * 10000) / 10000;\r\n    };\r\n    scale.domain = function (x) {\r\n        if (!arguments.length) return backingLinearScale.domain();\r\n        backingLinearScale.domain(x);\r\n        return scale;\r\n    };\r\n    scale.range = function (x) {\r\n        if (!arguments.length) return backingLinearScale.range();\r\n        backingLinearScale.range(x);\r\n        return scale;\r\n    };\r\n    scale.rangeRound = function (x) {\r\n        return backingLinearScale.range(x);\r\n    };\r\n    scale.clamp = function (x) {\r\n        if (!arguments.length) return backingLinearScale.clamp();\r\n        backingLinearScale.clamp(x);\r\n        return scale;\r\n    };\r\n    scale.interpolate = function (x) {\r\n        if (!arguments.length) return backingLinearScale.interpolate();\r\n        backingLinearScale.interpolate(x);\r\n        return scale;\r\n    };\r\n    scale.ticks = function (m, flexTicks) {\r\n        const backingTicks = backingLinearScale.ticks(m);\r\n        const ticksMap = map();\r\n\r\n        const [domainStart, domainEnd] = backingLinearScale.domain();\r\n\r\n        const start =\r\n            Math.max(Math.ceil(domainStart), head(index).index) +\r\n            Math.abs(head(index).index);\r\n        const end =\r\n            Math.min(Math.floor(domainEnd), last(index).index) +\r\n            Math.abs(head(index).index);\r\n\r\n        if (Math.floor(domainEnd) > end) {\r\n            // console.log(end, domainEnd, index);\r\n        }\r\n\r\n        const desiredTickCount = Math.ceil(\r\n            ((end - start) / (domainEnd - domainStart)) * backingTicks.length\r\n        );\r\n\r\n        for (let i = MAX_LEVEL; i >= 0; i--) {\r\n            const ticksAtLevel = ticksMap.get(i);\r\n            const temp = isNotDefined(ticksAtLevel) ? [] : ticksAtLevel.slice();\r\n\r\n            for (let j = start; j <= end; j++) {\r\n                if (index[j].level === i) {\r\n                    temp.push(index[j]);\r\n                }\r\n            }\r\n\r\n            ticksMap.set(i, temp);\r\n        }\r\n\r\n        let unsortedTicks = [];\r\n        for (let i = MAX_LEVEL; i >= 0; i--) {\r\n            if (\r\n                ticksMap.get(i).length + unsortedTicks.length >\r\n                desiredTickCount * 1.5\r\n            )\r\n                break;\r\n            unsortedTicks = unsortedTicks.concat(\r\n                ticksMap.get(i).map((d) => d.index)\r\n            );\r\n        }\r\n\r\n        const ticks = unsortedTicks.sort(ascending);\r\n\r\n        // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\r\n\r\n        if (!flexTicks && end - start > ticks.length) {\r\n            const ticksSet = set(ticks);\r\n\r\n            const d = Math.abs(head(index).index);\r\n\r\n            // ignore ticks within this distance\r\n            const distance = Math.ceil(\r\n                (backingTicks.length > 0\r\n                    ? (last(backingTicks) - head(backingTicks)) /\r\n                      backingTicks.length /\r\n                      4\r\n                    : 1) * 1.5\r\n            );\r\n\r\n            for (let i = 0; i < ticks.length - 1; i++) {\r\n                for (let j = i + 1; j < ticks.length; j++) {\r\n                    if (ticks[j] - ticks[i] <= distance) {\r\n                        ticksSet.remove(\r\n                            index[ticks[i] + d].level >=\r\n                                index[ticks[j] + d].level\r\n                                ? ticks[j]\r\n                                : ticks[i]\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            const tickValues = ticksSet.values().map((d) => parseInt(d, 10));\r\n\r\n            // console.log(ticks.length, tickValues, level);\r\n            // console.log(ticks, tickValues, distance);\r\n\r\n            return tickValues;\r\n        }\r\n\r\n        return ticks;\r\n    };\r\n    scale.tickFormat = function () {\r\n        return function (x) {\r\n            const d = Math.abs(head(index).index);\r\n            const { format, date } = index[Math.floor(x + d)];\r\n\r\n            if (date.getTime() == 0) {\r\n                return \"\";\r\n            }\r\n\r\n            return format(date);\r\n        };\r\n    };\r\n    scale.value = function (x) {\r\n        const d = Math.abs(head(index).index);\r\n        if (isDefined(index[Math.floor(x + d)])) {\r\n            const { date } = index[Math.floor(x + d)];\r\n            return date;\r\n        }\r\n    };\r\n    scale.nice = function (m) {\r\n        backingLinearScale.nice(m);\r\n        return scale;\r\n    };\r\n    scale.index = function (x) {\r\n        if (!arguments.length) return index;\r\n        index = x;\r\n        return scale;\r\n    };\r\n    scale.copy = function () {\r\n        return financeDiscontinuousScale(\r\n            index,\r\n            futureProvider,\r\n            backingLinearScale.copy()\r\n        );\r\n    };\r\n    return scale;\r\n}\r\n"]}