{"version":3,"sources":["../../../../src/lib/utils/barWidth.js"],"names":["head","plotDataLengthBarWidth","props","moreProps","widthRatio","xScale","range","l","r","totalWidth","Math","abs","invert","domain","dl","dr","width","length","timeIntervalBarWidth","interval","xAccessor","plotData","first","offset"],"mappings":";;AAEA,SAASA,IAAT,QAAqB,UAArB;;AAEA;;;;;;;AAOA,OAAO,SAASC,sBAAT,CAAgCC,KAAhC,EAAuCC,SAAvC,EAAkD;AAAA,KAChDC,UADgD,GACjCF,KADiC,CAChDE,UADgD;AAAA,KAEhDC,MAFgD,GAErCF,SAFqC,CAEhDE,MAFgD;;AAAA,qBAIzCA,OAAOC,KAAP,EAJyC;AAAA;AAAA,KAIjDC,CAJiD;AAAA,KAI9CC,CAJ8C;;AAMxD,KAAMC,aAAaC,KAAKC,GAAL,CAASH,IAAID,CAAb,CAAnB;AACA,KAAIF,OAAOO,MAAP,IAAiB,IAArB,EAA2B;AAAA,uBACTP,OAAOQ,MAAP,EADS;AAAA;AAAA,MACnBC,EADmB;AAAA,MACfC,EADe;;AAE1B,MAAMC,QAAQP,aAAaC,KAAKC,GAAL,CAASG,KAAKC,EAAd,CAA3B;AACA,SAAOC,QAAQZ,UAAf;AACA,EAJD,MAIO;AACN,MAAMY,SAAQP,aAAaJ,OAAOQ,MAAP,GAAgBI,MAA3C;AACA,SAAOD,SAAQZ,UAAf;AACA;AACD;;AAED;;;;;AAKA,OAAO,SAASc,oBAAT,CAA8BC,QAA9B,EAAwC;AAC9C,QAAO,UAASjB,KAAT,EAAgBC,SAAhB,EAA2B;AAAA,MACzBC,UADyB,GACVF,KADU,CACzBE,UADyB;AAAA,MAEzBC,MAFyB,GAEOF,SAFP,CAEzBE,MAFyB;AAAA,MAEjBe,SAFiB,GAEOjB,SAFP,CAEjBiB,SAFiB;AAAA,MAENC,QAFM,GAEOlB,SAFP,CAENkB,QAFM;;;AAIjC,MAAMC,QAAQF,UAAUpB,KAAKqB,QAAL,CAAV,CAAd;AACA,SAAOX,KAAKC,GAAL,CAASN,OAAOc,SAASI,MAAT,CAAgBD,KAAhB,EAAuB,CAAvB,CAAP,IAAoCjB,OAAOiB,KAAP,CAA7C,IAA8DlB,UAArE;AACA,EAND;AAOA","file":"barWidth.js","sourcesContent":["\r\n\r\nimport { head } from \"../utils\";\r\n\r\n/**\r\n * Bar width is based on the amount of items in the plot data and the distance between the first and last of those\r\n * items.\r\n * @param props the props passed to the series.\r\n * @param moreProps an object holding the xScale, xAccessor and plotData.\r\n * @return {number} the bar width.\r\n */\r\nexport function plotDataLengthBarWidth(props, moreProps) {\r\n\tconst { widthRatio } = props;\r\n\tconst { xScale } = moreProps;\r\n\r\n\tconst [l, r] = xScale.range();\r\n\r\n\tconst totalWidth = Math.abs(r - l);\r\n\tif (xScale.invert != null) {\r\n\t\tconst [dl, dr] = xScale.domain();\r\n\t\tconst width = totalWidth / Math.abs(dl - dr);\r\n\t\treturn width * widthRatio;\r\n\t} else {\r\n\t\tconst width = totalWidth / xScale.domain().length;\r\n\t\treturn width * widthRatio;\r\n\t}\r\n}\r\n\r\n/**\r\n * Generates a width function that calculates the bar width based on the given time interval.\r\n * @param interval a d3-time time interval.\r\n * @return {Function} the width function.\r\n */\r\nexport function timeIntervalBarWidth(interval) {\r\n\treturn function(props, moreProps) {\r\n\t\tconst { widthRatio } = props;\r\n\t\tconst { xScale, xAccessor, plotData } = moreProps;\r\n\r\n\t\tconst first = xAccessor(head(plotData));\r\n\t\treturn Math.abs(xScale(interval.offset(first, 1)) - xScale(first)) * widthRatio;\r\n\t};\r\n}\r\n"]}